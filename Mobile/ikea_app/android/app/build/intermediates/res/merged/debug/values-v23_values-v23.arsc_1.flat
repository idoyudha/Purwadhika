                            inputOptions.inlineDynamicImports === true
                                        ? ''
                                        : ' To inline dynamic imports, set the "inlineDynamicImports" option.')
                            });
                    }
                    yield Promise.all(Object.keys(bundle).map(chunkId => writeOutputFile(result, bundle[chunkId], outputOptions, outputPluginDriver)));
                    yield outputPluginDriver.hookParallel('writeBundle', [bundle]);
                    return createOutput(bundle);
                }));
            })
        };
        if (inputOptions.perf === true)
            result.getTimings = getTimings;
        return result;
    });
}
var SortingFileType;
(function (SortingFileType) {
    SortingFileType[SortingFileType["ENTRY_CHUNK"] = 0] = "ENTRY_CHUNK";
    SortingFileType[SortingFileType["SECONDARY_CHUNK"] = 1] = "SECONDARY_CHUNK";
    SortingFileType[SortingFileType["ASSET"] = 2] = "ASSET";
})(SortingFileType || (SortingFileType = {}));
function getSortingFileType(file) {
    if (file.type === 'asset') {
        return SortingFileType.ASSET;
    }
    if (file.isEntry) {
        return SortingFileType.ENTRY_CHUNK;
    }
    return SortingFileType.SECONDARY_CHUNK;
}
function createOutput(outputBundle) {
    return {
        output: Object.keys(outputBundle)
            .map(fileName => outputBundle[fileName])
            .filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => {
            const fileTypeA = getSortingFileType(outputFileA);
            const fileTypeB = getSortingFileType(outputFileB);
            if (fileTypeA === fileTypeB)
                return 0;
            return fileTypeA < fileTypeB ? -1 : 1;
        })
    };
}
function writeOutputFile(build, outputFile, outputOptions, outputPluginDriver) {
    const fileName = resolve(outputOptions.dir || dirname(outputOptions.file), outputFile.fileName);
    let writeSourceMapPromise;
    let source;
    if (outputFile.type === 'asset') {
        source = outputFile.source;
    }
    else {
        source = outputFile.code;
        if (outputOptions.sourcemap && outputFile.map) {
            let url;
            if (outputOptions.sourcemap === 'inline') {
                url = outputFile.map.toUrl();
            }
            else {
                url = `${basename(outputFile.fileName)}.map`;
                writeSourceMapPromise = writeFile(`${fileName}.map`, outputFile.map.toString());
            }
            if (outputOptions.sourcemap !== 'hidden') {
                source += `//# ${SOURCEMAPPING_URL}=${url}\n`;
            }
        }
    }
    return writeFile(fileName, source)
        .then(() => writeSourceMapPromise)
        .then(() => outputFile.type === 'chunk' &&
        outputPluginDriver.hookSeq('onwrite', [
            Object.assign({ bundle: build }, outputOptions),
            outputFile
        ]))
        .then(() => { });
}
function normalizeOutputOptions(inputOptions, rawOutputOptions, hasMultipleChunks, outputPluginDriver) {
    const mergedOptions = mergeOptions({
        config: {
            output: Object.assign(Object.assign(Object.assign({}, rawOutputOptions), rawOutputOptions.output), inputOptions.output)
        }
    });
    if (mergedOptions.optionError)
        throw new Error(mergedOptions.optionError);
    // now outputOptions is an array, but rollup.rollup API doesn't support arrays
    const mergedOutputOptions = mergedOptions.outputOptions[0];
    const outputOptionsReducer = (outputOptions, result) => result || outputOptions;
    const outputOptions = outputPluginDriver.hookReduceArg0Sync('outputOptions', [mergedOutputOptions], outputOptionsReducer, pluginContext => {
        const emitError = () => pluginContext.error(errCannotEmitFromOptionsHook());
        return Object.assign(Object.assign({}, pluginContext), { emitFile: emitError, setAssetSource: emitError });
    });
    checkOutputOptions(outputOpt